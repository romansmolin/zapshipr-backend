import youtubedl from 'youtube-dl-exec'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

import type { ILogger } from '@/shared/logger/logger.interface'
import { AppError, ErrorMessageCode } from '@/shared/errors/app-error'

import type {
    ITranscriptProviderService,
    AvailableCaptionsResult,
    CaptionTrack,
    DownloadCaptionsResult,
    DownloadCaptionsOptions,
    TranscriptProviderErrorCode,
} from './transcript-provider-service.interface'

interface YtDlpSubtitleInfo {
    ext?: string
    url?: string
    name?: string
}

interface YtDlpVideoInfo {
    id: string
    title?: string
    duration?: number
    subtitles?: Record<string, YtDlpSubtitleInfo[]>
    automatic_captions?: Record<string, YtDlpSubtitleInfo[]>
    availability?: string
    age_limit?: number
}

export class TranscriptProviderService implements ITranscriptProviderService {
    private readonly tempDir: string

    constructor(private readonly logger: ILogger) {
        this.tempDir = path.join(os.tmpdir(), 'zapshipr-transcripts')
    }

    async getAvailableCaptions(videoId: string): Promise<AvailableCaptionsResult> {
        this.logger.info('Fetching available captions', {
            operation: 'TranscriptProviderService.getAvailableCaptions',
            videoId,
        })

        try {
            const info = await this.getVideoInfo(videoId)

            const humanCaptions = this.parseCaptionTracks(info.subtitles || {}, false)
            const autoCaptions = this.parseCaptionTracks(info.automatic_captions || {}, true)

            const result: AvailableCaptionsResult = {
                videoId,
                title: info.title,
                durationSec: info.duration,
                humanCaptions,
                autoCaptions,
                hasCaptions: humanCaptions.length > 0 || autoCaptions.length > 0,
            }

            this.logger.info('Found captions', {
                operation: 'TranscriptProviderService.getAvailableCaptions',
                videoId,
                humanCaptionsCount: humanCaptions.length,
                autoCaptionsCount: autoCaptions.length,
                humanLanguages: humanCaptions.map((c) => c.language).join(', '),
                autoLanguages: autoCaptions.map((c) => c.language).join(', '),
            })

            return result
        } catch (error) {
            this.handleYtDlpError(error, videoId)
            throw error // TypeScript flow
        }
    }

    async downloadCaptions(
        videoId: string,
        options: DownloadCaptionsOptions = {}
    ): Promise<DownloadCaptionsResult> {
        const { preferredLanguage = 'en', preferHuman = true, format = 'vtt' } = options

        this.logger.info('Downloading captions', {
            operation: 'TranscriptProviderService.downloadCaptions',
            videoId,
            preferredLanguage,
            preferHuman,
            format,
        })

        // Get available captions first
        const available = await this.getAvailableCaptions(videoId)

        if (!available.hasCaptions) {
            throw this.createError('NO_CAPTIONS_AVAILABLE', videoId, 'No captions available for this video')
        }

        // Find best caption track using fallback strategy
        const selectedTrack = this.selectBestCaptionTrack(
            available.humanCaptions,
            available.autoCaptions,
            preferredLanguage,
            preferHuman
        )

        if (!selectedTrack) {
            throw this.createError('NO_CAPTIONS_AVAILABLE', videoId, 'Could not find suitable caption track')
        }

        // Download the captions
        const content = await this.downloadCaptionTrack(videoId, selectedTrack, format)

        const result: DownloadCaptionsResult = {
            videoId,
            language: selectedTrack.language,
            source: selectedTrack.isAutoGenerated ? 'auto_captions' : 'human_captions',
            format,
            content,
        }

        this.logger.info('Downloaded captions successfully', {
            operation: 'TranscriptProviderService.downloadCaptions',
            videoId,
            language: selectedTrack.language,
            source: result.source,
            contentLength: content.length,
        })

        return result
    }

    async isVideoAccessible(videoId: string): Promise<boolean> {
        try {
            await this.getVideoInfo(videoId)
            return true
        } catch {
            return false
        }
    }

    /**
     * Get video info from yt-dlp
     */
    private async getVideoInfo(videoId: string): Promise<YtDlpVideoInfo> {
        const url = `https://www.youtube.com/watch?v=${videoId}`

        try {
            const info = (await youtubedl(url, {
                dumpSingleJson: true,
                noCheckCertificates: true,
                noWarnings: true,
                skipDownload: true,
                // Don't download anything, just get info
                writeAutoSub: false,
                writeSub: false,
            })) as YtDlpVideoInfo

            return info
        } catch (error) {
            this.handleYtDlpError(error, videoId)
            throw error
        }
    }

    /**
     * Parse caption tracks from yt-dlp format
     */
    private parseCaptionTracks(
        subtitles: Record<string, YtDlpSubtitleInfo[]>,
        isAutoGenerated: boolean
    ): CaptionTrack[] {
        const tracks: CaptionTrack[] = []

        for (const [langCode, formats] of Object.entries(subtitles)) {
            if (!formats || formats.length === 0) continue

            // Find VTT format if available, otherwise take first
            const vttFormat = formats.find((f) => f.ext === 'vtt')
            const bestFormat = vttFormat || formats[0]

            tracks.push({
                language: langCode,
                languageName: bestFormat.name || langCode,
                isAutoGenerated,
                format: bestFormat.ext,
            })
        }

        return tracks
    }

    /**
     * Select best caption track using fallback strategy
     */
    private selectBestCaptionTrack(
        humanCaptions: CaptionTrack[],
        autoCaptions: CaptionTrack[],
        preferredLanguage: string,
        preferHuman: boolean
    ): CaptionTrack | null {
        const primaryCaptions = preferHuman ? humanCaptions : autoCaptions
        const secondaryCaptions = preferHuman ? autoCaptions : humanCaptions

        // Strategy:
        // 1. Primary captions in preferred language
        // 2. Primary captions in any language (prefer English)
        // 3. Secondary captions in preferred language
        // 4. Secondary captions in any language (prefer English)

        // 1. Primary in preferred language
        let track = primaryCaptions.find((t) => t.language === preferredLanguage)
        if (track) return track

        // 2. Primary in English or first available
        track = primaryCaptions.find((t) => t.language === 'en') || primaryCaptions[0]
        if (track) return track

        // 3. Secondary in preferred language
        track = secondaryCaptions.find((t) => t.language === preferredLanguage)
        if (track) return track

        // 4. Secondary in English or first available
        track = secondaryCaptions.find((t) => t.language === 'en') || secondaryCaptions[0]
        return track || null
    }

    /**
     * Download specific caption track
     */
    private async downloadCaptionTrack(
        videoId: string,
        track: CaptionTrack,
        format: 'vtt' | 'srt'
    ): Promise<string> {
        const url = `https://www.youtube.com/watch?v=${videoId}`

        // Create temp directory if needed
        await fs.mkdir(this.tempDir, { recursive: true })

        const outputTemplate = path.join(this.tempDir, `${videoId}_${track.language}`)

        try {
            // Download the subtitles
            await youtubedl(url, {
                skipDownload: true,
                writeSub: !track.isAutoGenerated,
                writeAutoSub: track.isAutoGenerated,
                subLang: track.language,
                subFormat: format,
                output: outputTemplate,
                noCheckCertificates: true,
                noWarnings: true,
            })

            // Read the downloaded file
            const expectedFile = `${outputTemplate}.${track.language}.${format}`
            const altFile = `${outputTemplate}.${format}`

            let content: string
            try {
                content = await fs.readFile(expectedFile, 'utf-8')
                await fs.unlink(expectedFile).catch(() => {})
            } catch {
                try {
                    content = await fs.readFile(altFile, 'utf-8')
                    await fs.unlink(altFile).catch(() => {})
                } catch {
                    // Try to find any subtitle file that was created
                    const files = await fs.readdir(this.tempDir)
                    const subFile = files.find(
                        (f) => f.startsWith(videoId) && (f.endsWith('.vtt') || f.endsWith('.srt'))
                    )

                    if (subFile) {
                        const filePath = path.join(this.tempDir, subFile)
                        content = await fs.readFile(filePath, 'utf-8')
                        await fs.unlink(filePath).catch(() => {})
                    } else {
                        throw this.createError(
                            'CAPTION_DOWNLOAD_FAILED',
                            videoId,
                            'Failed to find downloaded caption file'
                        )
                    }
                }
            }

            return content
        } catch (error) {
            if (error instanceof AppError) throw error
            this.handleYtDlpError(error, videoId)
            throw error
        }
    }

    /**
     * Handle yt-dlp errors and convert to AppError
     */
    private handleYtDlpError(error: unknown, videoId: string): never {
        const errorMessage = error instanceof Error ? error.message : String(error)
        const lowerMessage = errorMessage.toLowerCase()

        let errorCode: TranscriptProviderErrorCode = 'YTDLP_ERROR'
        let userMessage = 'Failed to fetch video information'

        if (lowerMessage.includes('private video') || lowerMessage.includes('video is private')) {
            errorCode = 'VIDEO_PRIVATE'
            userMessage = 'This video is private'
        } else if (lowerMessage.includes('unavailable') || lowerMessage.includes('not available')) {
            errorCode = 'VIDEO_UNAVAILABLE'
            userMessage = 'This video is unavailable'
        } else if (lowerMessage.includes('age') || lowerMessage.includes('sign in to confirm your age')) {
            errorCode = 'VIDEO_AGE_RESTRICTED'
            userMessage = 'This video is age-restricted'
        } else if (lowerMessage.includes('blocked') || lowerMessage.includes('not available in your country')) {
            errorCode = 'VIDEO_REGION_BLOCKED'
            userMessage = 'This video is blocked in your region'
        }

        this.logger.error('yt-dlp error', {
            operation: 'TranscriptProviderService.handleYtDlpError',
            videoId,
            errorCode,
            originalError: errorMessage,
        })

        throw this.createError(errorCode, videoId, userMessage)
    }

    /**
     * Create AppError for transcript provider errors
     */
    private createError(code: TranscriptProviderErrorCode, videoId: string, message: string): AppError {
        return new AppError({
            errorMessageCode: ErrorMessageCode.INTERNAL_SERVER_ERROR,
            message: `[${code}] ${message} (videoId: ${videoId})`,
            httpCode: code === 'NO_CAPTIONS_AVAILABLE' ? 404 : 500,
        })
    }
}

